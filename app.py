# -*- coding: utf-8 -*-
"""Untitled47.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H525Mqi45WHgYGA6mhi7A0drqE0YrMLT
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import streamlit as st
# from dataclasses import dataclass, field
# from typing import Optional
# from copy import deepcopy
# 
# # ===================== CORE LOGIC ===================== #
# 
# @dataclass
# class ContextFrame:
#     value: Optional[str] = None
#     confidence: float = 0.0
# 
#     def decay(self, factor=0.85):
#         self.confidence *= factor
#         if self.confidence < 0.2:
#             self.value = None
# 
# 
# @dataclass
# class DialogueState:
#     domain: ContextFrame = field(default_factory=ContextFrame)
#     geography: ContextFrame = field(default_factory=ContextFrame)
#     role: ContextFrame = field(default_factory=ContextFrame)
#     intent: ContextFrame = field(default_factory=ContextFrame)
# 
#     def decay_all(self):
#         self.domain.decay()
#         self.geography.decay()
#         self.role.decay()
#         self.intent.decay()
# 
#     def snapshot(self):
#         return {
#             "domain": vars(self.domain),
#             "geography": vars(self.geography),
#             "role": vars(self.role),
#             "intent": vars(self.intent),
#         }
# 
# 
# def detect_dialogue_act(text: str) -> str:
#     t = text.lower()
# 
#     if any(x in t for x in ["thanks", "wait", "ok", "fine"]):
#         return "chit_chat"
# 
#     if any(x in t for x in ["now tell me", "switch to", "change topic"]):
#         return "topic_shift"
# 
#     if any(x in t for x in ["his ", "her ", "their ", "what about", "same"]):
#         return "contextual_continuation"
# 
#     return "fresh_query"
# 
# 
# COUNTRIES = ["india", "uk", "us", "united states"]
# SPORTS = ["cricket", "football"]
# 
# 
# def detect_domain(text):
#     t = text.lower()
#     if any(x in t for x in SPORTS):
#         return "Sports"
#     if "prime minister" in t or "pm" in t:
#         return "Politics"
#     return None
# 
# 
# def detect_geography(text):
#     t = text.lower()
#     for c in COUNTRIES:
#         if c in t:
#             return "US" if c in ["us", "united states"] else c.title()
#     return None
# 
# 
# def update_state_from_text(text, state: DialogueState):
#     domain = detect_domain(text)
#     geo = detect_geography(text)
# 
#     if domain and domain != state.domain.value:
#         state.role.value = None
#         state.role.confidence = 0.0
#         state.intent.value = None
#         state.intent.confidence = 0.0
# 
#     if domain:
#         state.domain.value = domain
#         state.domain.confidence = 1.0
# 
#     if geo:
#         state.geography.value = geo
#         state.geography.confidence = 1.0
# 
#     if "prime minister" in text.lower() or "pm" in text.lower():
#         state.role.value = "Prime Minister"
#         state.role.confidence = 1.0
# 
#     if "captain" in text.lower():
#         state.role.value = "Captain"
#         state.role.confidence = 1.0
# 
#     if "duties" in text.lower():
#         state.intent.value = "duties"
#         state.intent.confidence = 1.0
# 
# 
# def generate_expansion_candidates(text, state: DialogueState):
#     candidates = []
#     t = text.lower()
# 
#     if any(x in t for x in ["his duties", "her duties", "their duties"]):
#         if state.role.value and state.geography.value:
#             candidates.append(
#                 f"What are the duties of the {state.role.value} of {state.geography.value}?"
#             )
#         return candidates
# 
#     if "what about" in t:
#         geo = detect_geography(text)
#         if not geo:
#             return candidates
# 
#         if state.domain.value == "Sports":
#             if state.role.value == "Captain":
#                 candidates.append(f"Who is the captain of the {geo} team?")
#             else:
#                 candidates.append(f"What is the status of sports in {geo}?")
# 
#         elif state.domain.value == "Politics" and state.role.value == "Prime Minister":
#             candidates.append(
#                 f"Who is the prime minister of {geo} and what are his duties?"
#             )
# 
#     return candidates
# 
# 
# def resolve_expansion(candidates):
#     if not candidates:
#         return None, "no_context"
#     if len(candidates) == 1:
#         return candidates[0], None
#     return None, f"clarify: {candidates}"
# 
# 
# def assign_topic(text, state: DialogueState, act: str):
#     t = text.lower()
#     geo = state.geography.value or "NA"
# 
#     # Explicit domain signals always win
#     if "prime minister" in t or "pm" in t:
#         return "Politics", geo
# 
#     if "captain" in t or any(x in t for x in ["cricket", "football", "sports"]):
#         return "Sports", geo
# 
#     # ðŸ”´ CRITICAL FIX:
#     # For contextual continuation, never re-infer domain from silence
#     if act == "contextual_continuation" and state.domain.value:
#         return state.domain.value, geo
# 
#     # Fallback (fresh queries)
#     if state.domain.value:
#         return state.domain.value, geo
# 
#     return "General", "NA"
# 
# 
# 
# def process_turn(user_text, state: DialogueState):
#     state.decay_all()
#     act = detect_dialogue_act(user_text)
# 
#     if act == "chit_chat":
#         return None, ("General", "NA"), "chit_chat", state.snapshot()
# 
#     update_state_from_text(user_text, state)
# 
#     expanded, note = None, None
#     if act == "contextual_continuation":
#         candidates = generate_expansion_candidates(user_text, state)
#         expanded, note = resolve_expansion(candidates)
# 
#     topic = assign_topic(expanded if expanded else user_text, state, act)
# 
#     return expanded, topic, note, state.snapshot()
# 
# 
# # ===================== STREAMLIT UI ===================== #
# 
# st.set_page_config(page_title="Context-aware Query Expansion", layout="wide")
# st.title("Context-aware Query Expansion & Topic Tagging")
# 
# if "conversation" not in st.session_state:
#     st.session_state.conversation = []
#     st.session_state.state = DialogueState()
# 
# user_input = st.text_input("User input")
# 
# if st.button("Submit") and user_input:
#     expanded, topic, note, snap = process_turn(
#         user_input, st.session_state.state
#     )
#     st.session_state.conversation.append({
#         "user": user_input,
#         "expanded": expanded,
#         "topic": topic,
#         "note": note,
#         "state": deepcopy(snap)
#     })
# 
# col1, col2 = st.columns([2, 1])
# 
# with col1:
#     st.subheader("Conversation")
#     for turn in st.session_state.conversation:
#         st.markdown(f"**User:** {turn['user']}")
#         if turn["expanded"]:
#             st.markdown(f"**Expanded:** {turn['expanded']}")
#         st.markdown(f"**Topic:** {turn['topic'][0]} â†’ {turn['topic'][1]}")
#         if turn["note"]:
#             st.warning(turn["note"])
#         st.markdown("---")
# 
# with col2:
#     st.subheader("Dialogue State (latest)")
#     if st.session_state.conversation:
#         st.json(st.session_state.conversation[-1]["state"])
# 
# if st.button("Reset Conversation"):
#     st.session_state.conversation = []
#     st.session_state.state = DialogueState()
#